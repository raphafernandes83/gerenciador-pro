// ================================================================
// MAIN.JS - ARQUIVO PRINCIPAL
// ================================================================

// ================================================================
// SUPABASE INTEGRACAO
// ================================================================

// ================================================================
// ðŸ”§ CONFIGURAÃ‡Ã•ES CENTRALIZADAS DO SISTEMA
// ================================================================
import {
    SUPABASE_CONFIG,
    TIMING_CONFIG,
    PERFORMANCE_THRESHOLDS,
    SYSTEM_MESSAGES,
    STORAGE_KEYS,
} from './src/constants/SystemConstants.js';
import { getSupabaseEnv } from './src/config/EnvProvider.js';
import { generateRequestId } from './src/utils/SecurityUtils.js';
import { logger } from './src/utils/Logger.js'; // Movido para o topo - usado na linha 32
import './src/utils/SafeProtection.js';
import './src/monitoring/PerformanceDashboard.js';
import './tests/test-loader.js';

// ðŸ”§ ConfiguraÃ§Ãµes do Supabase com carregamento seguro de ambiente
const { url: ENV_SUPABASE_URL, anonKey: ENV_SUPABASE_ANON_KEY, isOfflineMode } = getSupabaseEnv();
const supabaseUrl = ENV_SUPABASE_URL || SUPABASE_CONFIG.URL;
const supabaseAnonKey = ENV_SUPABASE_ANON_KEY || SUPABASE_CONFIG.ANON_KEY;

// ðŸ›¡ï¸ ValidaÃ§Ã£o robusta de configuraÃ§Ã£o
if (!supabaseUrl || !supabaseAnonKey || supabaseUrl === 'offline') {
    logger.warn(
        'âš ï¸ Supabase nÃ£o configurado. Sistema funcionarÃ¡ em modo offline com funcionalidade limitada.'
    );
    window.__SUPABASE_OFFLINE_MODE__ = true;
} else {
    logger.info('âœ… ConfiguraÃ§Ã£o Supabase carregada:', {
        hasUrl: !!supabaseUrl,
        hasKey: !!supabaseAnonKey,
        isDevelopment: SUPABASE_CONFIG.DEVELOPMENT_MODE,
    });
    window.__SUPABASE_OFFLINE_MODE__ = false;
}

/**
 * ðŸ›¡ï¸ INICIALIZAÃ‡ÃƒO SEGURA DO CLIENTE SUPABASE
 * Implementa Null Object Pattern + Retry Pattern para mÃ¡xima seguranÃ§a
 */

/**
 * Objeto null-safe para substituir cliente Supabase quando indisponÃ­vel
 * Previne crashes e logging de credenciais em produÃ§Ã£o
 */
const createNullSupabaseClient = () => ({
    auth: {
        getUser: async () => ({
            data: null,
            error: { message: 'Cliente Supabase nÃ£o disponÃ­vel', code: 'CLIENT_UNAVAILABLE' },
        }),
        signIn: async () => ({
            data: null,
            error: { message: 'Cliente Supabase nÃ£o disponÃ­vel', code: 'CLIENT_UNAVAILABLE' },
        }),
        signOut: async () => ({
            data: null,
            error: { message: 'Cliente Supabase nÃ£o disponÃ­vel', code: 'CLIENT_UNAVAILABLE' },
        }),
    },
    from: () => ({
        select: () => ({ data: [], error: null }),
        insert: () => ({ data: null, error: { message: 'Cliente Supabase nÃ£o disponÃ­vel' } }),
        update: () => ({ data: null, error: { message: 'Cliente Supabase nÃ£o disponÃ­vel' } }),
        delete: () => ({ data: null, error: { message: 'Cliente Supabase nÃ£o disponÃ­vel' } }),
    }),
    storage: {
        from: () => ({
            upload: async () => ({ data: null, error: { message: 'Storage nÃ£o disponÃ­vel' } }),
            download: async () => ({ data: null, error: { message: 'Storage nÃ£o disponÃ­vel' } }),
        }),
    },
    isNull: true, // Flag para identificar cliente null
});

// Cliente Supabase com inicializaÃ§Ã£o segura garantida
let supabase = createNullSupabaseClient();

/**
 * Inicializa cliente Supabase com retry inteligente e logging seguro
 * @private
 */
const initializeSupabaseClient = () => {
    try {
        // ðŸ›¡ï¸ VerificaÃ§Ã£o prÃ©via de configuraÃ§Ã£o
        if (window.__SUPABASE_OFFLINE_MODE__) {
            logger.info('ðŸŽ® Sistema em modo offline - Supabase nÃ£o serÃ¡ inicializado');
            return false;
        }

        if (!supabaseUrl || !supabaseAnonKey || supabaseUrl === 'offline') {
            logger.warn('âš ï¸ Credenciais Supabase ausentes. Verifique a configuraÃ§Ã£o.');
            return false;
        }

        if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
            const client = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

            // ðŸ” ValidaÃ§Ã£o robusta do cliente
            if (client && typeof client.auth === 'object' && typeof client.from === 'function') {
                supabase = client;
                logger.debug('âœ… Cliente Supabase inicializado com sucesso!');
                return true;
            } else {
                logger.error('âŒ Cliente Supabase criado mas invÃ¡lido');
                return false;
            }
        } else {
            logger.error(
                'âŒ Biblioteca Supabase nÃ£o carregada. Verifique se o script estÃ¡ incluÃ­do no HTML.'
            );
            return false;
        }
    } catch (error) {
        // ðŸ›¡ï¸ Log seguro sem vazamento de credenciais
        logger.error('âŒ Erro na inicializaÃ§Ã£o do Supabase:', {
            message: error.message,
            timestamp: new Date().toISOString(),
            hasCredentials: !!(supabaseUrl && supabaseAnonKey),
            libraryAvailable: typeof window.supabase !== 'undefined',
            errorType: error.constructor.name,
        });
        return false;
    }
};

/**
 * Sistema de retry com backoff exponencial para inicializaÃ§Ã£o robusta
 * @private
 */
const initializeSupabaseWithRetry = async () => {
    const maxRetries = SUPABASE_CONFIG.MAX_RETRY_ATTEMPTS;
    let retryDelay = SUPABASE_CONFIG.RETRY_DELAY;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        if (initializeSupabaseClient()) {
            return; // Sucesso na inicializaÃ§Ã£o
        }

        if (attempt < maxRetries) {
            logger.warn(
                `âš ï¸ Tentativa ${attempt}/${maxRetries} falhou. Retry em ${retryDelay}ms...`
            );
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            retryDelay *= 2; // Backoff exponencial
        }
    }

    logger.warn(SYSTEM_MESSAGES.WARNING.SUPABASE_FAILED);
    logger.info('â„¹ï¸ Sistema continuarÃ¡ funcionando com cliente null-safe');
};

// InicializaÃ§Ã£o imediata ou com retry
if (!initializeSupabaseClient()) {
    // Async retry sem bloquear thread principal
    initializeSupabaseWithRetry().catch((error) => {
        logger.error('ðŸ’¥ Falha crÃ­tica na inicializaÃ§Ã£o do Supabase:', error.message);
    });
}

/**
 * ðŸ” TESTE SEGURO DE CONEXÃƒO SUPABASE
 * Implementa validaÃ§Ã£o completa com categorizaÃ§Ã£o de erros e logging seguro
 *
 * @returns {Promise<boolean>} True se conexÃ£o vÃ¡lida, false caso contrÃ¡rio
 */
async function testSupabaseConnection() {
    logger.debug('ðŸ” Iniciando teste de conexÃ£o Supabase...');
    const requestId = generateRequestId('supabase');

    // Guard Clause 1: Verifica se cliente existe
    if (!supabase) {
        logger.error('âŒ Cliente Supabase Ã© null/undefined');
        return false;
    }

    // Guard Clause 2: Verifica se Ã© cliente null-safe (nÃ£o conectado)
    if (supabase.isNull === true) {
        logger.warn('âš ï¸ Usando cliente Supabase null-safe (biblioteca nÃ£o carregada)');
        return false;
    }

    // Guard Clause 3: Verifica se cliente tem interface esperada
    if (!supabase.auth || typeof supabase.auth.getUser !== 'function') {
        logger.error('âŒ Cliente Supabase com interface invÃ¡lida');
        return false;
    }

    try {
        // Teste de conectividade com timeout de seguranÃ§a
        const connectionTest = Promise.race([
            supabase.auth.getUser(),
            new Promise((_, reject) =>
                setTimeout(
                    () => reject(new Error('Timeout na conexÃ£o')),
                    SUPABASE_CONFIG.CONNECTION_TIMEOUT || 5000
                )
            ),
        ]);

        const { data: user, error: authError } = await connectionTest;

        // CategorizaÃ§Ã£o inteligente de erros
        if (authError) {
            // Tentativa de recuperar sessÃ£o expirada
            if (authError.code === 'JWT_EXPIRED' && supabase?.auth?.refreshSession) {
                try {
                    const { data: refreshed, error: refreshError } =
                        await supabase.auth.refreshSession();
                    if (!refreshError) {
                        logger.info('ðŸ” SessÃ£o renovada com sucesso');
                        return true;
                    }
                } catch (_) {
                    /* silencioso */
                }
            }
            return _categorizeSupabaseError(authError);
        }

        // ConexÃ£o bem-sucedida - logging seguro
        _logSuccessfulConnection(user);
        return true;
    } catch (error) {
        return _handleConnectionException(error);
    }
}

/**
 * Categoriza erros do Supabase para diagnÃ³stico preciso
 * @private
 * @param {Object} authError - Erro retornado pelo Supabase
 * @returns {boolean} False sempre (erro detectado)
 */
function _categorizeSupabaseError(authError) {
    const errorCode = authError.code || 'UNKNOWN';
    const errorMessage = authError.message || 'Erro desconhecido';

    switch (errorCode) {
        case 'CLIENT_UNAVAILABLE':
            logger.warn('âš ï¸ Cliente Supabase nÃ£o disponÃ­vel (esperado)');
            return false;

        case 'NETWORK_ERROR':
        case 'CONNECTION_TIMEOUT':
            logger.error('ðŸŒ Erro de rede na conexÃ£o Supabase:', {
                code: errorCode,
                type: 'network',
                timestamp: new Date().toISOString(),
            });
            return false;

        case 'AUTH_SESSION_MISSING':
        case 'JWT_EXPIRED':
            // Estes sÃ£o erros "normais" quando usuÃ¡rio nÃ£o estÃ¡ logado
            logger.info('â„¹ï¸ Nenhuma sessÃ£o ativa (normal para primeira execuÃ§Ã£o)');
            return true; // ConexÃ£o OK, apenas sem usuÃ¡rio logado

        case 'UNKNOWN':
            // Tratamento especÃ­fico para "Auth session missing!" que vem sem cÃ³digo especÃ­fico
            if (errorMessage === 'Auth session missing!') {
                logger.info('â„¹ï¸ SessÃ£o nÃ£o encontrada (comportamento normal na inicializaÃ§Ã£o)');
                return true; // ConexÃ£o OK, apenas sem usuÃ¡rio logado
            }
            // Para outros erros UNKNOWN, continua para o default
            logger.warn('âš ï¸ Erro de autenticaÃ§Ã£o desconhecido:', errorCode);
            return false;

        default:
            // ðŸ”§ CORREÃ‡ÃƒO: Log menos agressivo para erros nÃ£o categorizados
            logger.warn('âš ï¸ Erro Supabase nÃ£o categorizado:', {
                code: errorCode,
                message: errorMessage.substring(0, 100), // Limita tamanho do log
                type: 'uncategorized',
                timestamp: new Date().toISOString(),
                note: 'Este tipo de erro pode ser normal durante inicializaÃ§Ã£o',
            });
            return false;
    }
}

/**
 * Logging seguro de conexÃ£o bem-sucedida
 * @private
 * @param {Object} user - Dados do usuÃ¡rio (pode ser null)
 */
function _logSuccessfulConnection(user) {
    logger.debug(SYSTEM_MESSAGES.SUCCESS.SUPABASE_CONNECTED);

    if (user && user.user) {
        // Logging seguro - nÃ£o expÃµe dados sensÃ­veis completos
        const userInfo = {
            hasUser: true,
            emailDomain: user.user.email ? user.user.email.split('@')[1] : 'unknown',
            provider: user.user.app_metadata?.provider || 'unknown',
            confirmed: user.user.email_confirmed_at ? 'yes' : 'no',
        };
        logger.debug('ðŸ‘¤ UsuÃ¡rio conectado:', userInfo);
    } else {
        logger.debug('â„¹ï¸ ConexÃ£o estabelecida - nenhum usuÃ¡rio logado');
    }
}

/**
 * Tratamento de exceÃ§Ãµes durante teste de conexÃ£o
 * @private
 * @param {Error} error - ExceÃ§Ã£o capturada
 * @returns {boolean} False sempre (exceÃ§Ã£o = falha)
 */
function _handleConnectionException(error) {
    const errorType = error.name || 'UnknownError';
    const errorMessage = error.message || 'Erro desconhecido';

    // CategorizaÃ§Ã£o de exceÃ§Ãµes
    if (errorMessage.includes('timeout') || errorMessage.includes('Timeout')) {
        logger.error('â±ï¸ Timeout na conexÃ£o Supabase:', {
            type: 'timeout',
            duration: SUPABASE_CONFIG.CONNECTION_TIMEOUT,
            suggestion: 'Verificar conectividade de rede',
        });
    } else if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
        logger.error('ðŸŒ Falha de rede:', {
            type: 'network',
            suggestion: 'Verificar conectividade ou URL do Supabase',
        });
    } else {
        logger.error('ðŸ’¥ ExceÃ§Ã£o na conexÃ£o Supabase:', {
            type: errorType,
            message: errorMessage.substring(0, 100),
            timestamp: new Date().toISOString(),
        });
    }

    return false;
}

// ================================================================
// FIM DA INTEGRACAO SUPABASE INICIAL
// ================================================================

// ================================================================
// ðŸ­ NOVA ARQUITETURA: DEPENDENCY INJECTION
// ================================================================
import { dependencyInjector } from './src/core/DependencyInjector.js';

// ================================================================
// ðŸ“¦ IMPORTS ESSENCIAIS (apenas mÃ³dulos legados crÃ­ticos)
// ================================================================
import { mapDOM, dom } from './dom.js';
import { dbManager } from './db.js';
import {
    logic,
    calcularExpectativaMatematica,
    calcularDrawdown,
    calcularSequencias,
    calcularPayoffRatio,
    updateState,
} from './logic.js';
import { events } from './events.js';
import { ui } from './ui.js';
import { charts } from './charts.js';
// ðŸš€ CORREÃ‡ÃƒO CRÃTICA: Componentes UI avanÃ§ados (Modal, Timeline, Tabela)
import { initComponents } from './src/init-components.js';
// ðŸŽ¯ CORREÃ‡ÃƒO: Controlador do modal de seleÃ§Ã£o de modo de sessÃ£o
import './src/ui/SessionModalController.js';
import { renderParametersCardIn } from './src/ui/templates/ParametersCardTemplate.js';
import { generateParametersCardHTML } from './src/ui/templates/ParametersCardTemplate.js';
import { ParametersCardController } from './src/ui/templates/ParametersCardController.js';
import {
    computeStopGoals,
    formatStopGoals,
    computeStopStatus,
    computeNextActionHint,
    computeLockMode,
} from './src/utils/GoalsUtils.js';

// Mapeia novos elementos para DOM helper se existir
try {
    window.dom = window.dom || {};
    dom.winTargetAmount = dom.winTargetAmount;
    dom.winRemainingAmount = dom.winRemainingAmount;
    dom.lossLimitAmount = dom.lossLimitAmount;
    dom.lossMarginAmount = dom.lossMarginAmount;
} catch { }
import { CONSTANTS, state, config } from './state.js';
import { validation } from './validation.js';

// ================================================================
// ðŸ“¦ IMPORTS PARA EXPOSIÃ‡ÃƒO GLOBAL DOS MÃ“DULOS REFATORADOS
// ================================================================
import {
    TRADING_STRATEGIES,
    SESSION_MODES,
    ERROR_MESSAGES,
    PERFORMANCE_CONFIG,
} from './src/constants/AppConstants.js';
import {
    calculateEntryAmount,
    calculateReturnAmount,
    calculateMathematicalExpectancy,
} from './src/utils/MathUtils.js';
import { TradingStrategyFactory } from './src/business/TradingStrategy.js';
import { errorHandler } from './src/utils/ErrorHandler.js';
import { debounce, memoize, measurePerformance } from './src/utils/PerformanceUtils.js';
import { TradingOperationsManager } from './src/business/TradingOperationsManager.js';
import { legacyAdapter } from './src/adapters/LegacyIntegrationAdapter.js';
import { performanceMonitor } from './src/monitoring/PerformanceMonitor.js';
import { cacheManager } from './src/enhancements/CacheManager.js';
import { smartErrorRecovery } from './src/enhancements/SmartErrorRecovery.js';
import { ToastManager } from './src/ui/ToastManager.js';
import { SkeletonLoader } from './src/ui/SkeletonLoader.js';
import './src/ui/skeleton-examples.js';
import { ErrorBoundary, ErrorBoundaryManager } from './src/monitoring/ErrorBoundary.js';
import { MetasUI } from './src/ui/MetasUI.js';
import {
    registerAdvancedStrategies,
    demonstrateAdvancedStrategies,
    AdvancedStrategiesUtils,
} from './src/strategies/AdvancedStrategies.js';
// logger import movido para o topo do arquivo (linha 21)
// ================================================================
// ðŸš€ MATH UTILS TURBO MODE - MIGRATION PREPARED
// ================================================================
import { MigrationControl } from './src/utils/MathUtilsMigrator.js';

// âš ï¸ NOTA: Turbo mode desabilitado temporariamente devido a bug no PrecisionHelper
// Bug: Cannot read properties of undefined (reading 'checkNaN') em MathUtilsTurbo.js:357
// Sistema continua em modo gradual (seguro e funcional)
// TODO: Corrigir PrecisionHelper em MathUtilsTurbo.js antes de ativar
// MigrationControl.enableAllTurbo();
logger.info('ðŸ”„ MathUtils em modo GRADUAL (seguro) - Turbo aguardando correÃ§Ã£o');

// ================================================================
// EXPOR MÃ“DULOS GLOBALMENTE PARA OS TESTES
// ================================================================
window.logic = logic;
window.state = state;
window.config = config;
window.ui = ui;
window.charts = charts;
window.validation = validation;
window.dbManager = dbManager;
window.dom = dom;
// ðŸ›¡ï¸ CORREÃ‡ÃƒO CRÃTICA: Expor events globalmente para testes
window.events = events;

// Expor funÃ§Ãµes exportadas individuais para os testes
window.calcularExpectativaMatematica = calcularExpectativaMatematica;
window.calcularDrawdown = calcularDrawdown;
window.calcularSequencias = calcularSequencias;
window.calcularPayoffRatio = calcularPayoffRatio;
window.updateState = updateState;

// Expor novos mÃ³dulos refatorados para testes
window.TRADING_STRATEGIES = TRADING_STRATEGIES;
window.SESSION_MODES = SESSION_MODES;
window.ERROR_MESSAGES = ERROR_MESSAGES;
window.PERFORMANCE_CONFIG = PERFORMANCE_CONFIG;
window.calculateEntryAmount = calculateEntryAmount;
window.calculateReturnAmount = calculateReturnAmount;
window.calculateMathematicalExpectancy = calculateMathematicalExpectancy;
window.TradingStrategyFactory = TradingStrategyFactory;
window.errorHandler = errorHandler;
window.debounce = debounce;
window.memoize = memoize;
window.measurePerformance = measurePerformance;
window.TradingOperationsManager = TradingOperationsManager;
window.legacyAdapter = legacyAdapter;
window.performanceMonitor = performanceMonitor;
window.cacheManager = cacheManager;
window.smartErrorRecovery = smartErrorRecovery;
window.registerAdvancedStrategies = registerAdvancedStrategies;
window.demonstrateAdvancedStrategies = demonstrateAdvancedStrategies;
window.AdvancedStrategiesUtils = AdvancedStrategiesUtils;
// Expor template para uso dinÃ¢mico no sidebar
window.generateParametersCardHTML = generateParametersCardHTML;

// ================================================================
// ðŸŽ¯ INICIALIZAÃ‡ÃƒO: MetasUI para Stop Win/Loss
// ================================================================
import { initializeMetasIntegration } from './metas-integration.js';

const metasUI = new MetasUI();
metasUI.init();
window.metasUI = metasUI;

// Inicializa integraÃ§Ã£o via eventos
initializeMetasIntegration();

logger.info('ðŸŽ¯ MetasUI ativado e integrado com eventos');

/**
 * ðŸš€ APLICAÃ‡ÃƒO PRINCIPAL - ARQUITETURA LIMPA v9.3
 * Responsabilidade Ãºnica: Orquestrar a inicializaÃ§Ã£o do sistema
 *
 * @class App
 * @author Gerenciador PRO Team
 * @version 9.3
 */
// ðŸ”§ CORREÃ‡ÃƒO: Ativar card principal de parÃ¢metros
window.__SHOW_MAIN_PARAMETERS_CARD__ = true;

// ðŸ”§ CORREÃ‡ÃƒO: Arquivos de correÃ§Ã£o removidos durante limpeza (Fase 3)
// O painel minimizÃ¡vel estÃ¡ funcionando corretamente sem esses arquivos

class App {
    constructor() {
        this.tradingManager = null;
        this.initialized = false;
        this.initializationSteps = [];
        this.startTime = 0;
        this.dependencies = null;

        // ConfiguraÃ§Ã£o de inicializaÃ§Ã£o usando constantes centralizadas
        this.INITIALIZATION_CONFIG = {
            SUPABASE_RETRY_ATTEMPTS: SUPABASE_CONFIG.MAX_RETRY_ATTEMPTS,
            SIDEBAR_INIT_DELAY: TIMING_CONFIG.INITIALIZATION.SIDEBAR_INIT_DELAY,
            UI_SYNC_TIMEOUT: TIMING_CONFIG.INITIALIZATION.UI_SYNC_TIMEOUT,
            MODULE_LOAD_TIMEOUT: TIMING_CONFIG.INITIALIZATION.MODULE_LOAD_TIMEOUT,
        };

        // ðŸ›¡ï¸ NÃƒO chama init() no constructor para evitar problemas assÃ­ncronos
    }

    /**
     * ðŸ›¡ï¸ ValidaÃ§Ã£o anti-recursÃ£o
     * Detecta padrÃµes de recursÃ£o infinita antes que aconteÃ§am
     */
    validateNoRecursion() {
        const callStack = new Error().stack;
        const lines = callStack.split('\n');

        // Verifica se hÃ¡ mais de 5 chamadas para o mesmo mÃ©todo
        const methodCounts = {};
        lines.forEach((line) => {
            const match = line.match(/at\s+(\w+\.\w+|\w+)/);
            if (match) {
                const method = match[1];
                methodCounts[method] = (methodCounts[method] || 0) + 1;
            }
        });

        for (const [method, count] of Object.entries(methodCounts)) {
            if (count > 5) {
                logger.error(`ðŸš¨ RecursÃ£o detectada: ${method} chamado ${count} vezes`);
                return false;
            }
        }

        return true;
    }

    /**
     * ðŸ›¡ï¸ InicializaÃ§Ã£o segura do sistema de erro
     */
    initSafeErrorHandling() {
        try {
            const { errorHandler } = this.dependencies.utils;

            if (errorHandler && errorHandler.setupGlobalErrorHandling) {
                // Wrapper com timeout de seguranÃ§a
                const timeoutId = setTimeout(() => {
                    logger.warn('âš ï¸ Timeout na inicializaÃ§Ã£o do errorHandler');
                }, TIMING_CONFIG.INITIALIZATION.ERROR_HANDLER_TIMEOUT);

                errorHandler.setupGlobalErrorHandling();
                clearTimeout(timeoutId);
                logger.debug('âœ… Error handling ativo');
            }
        } catch (error) {
            logger.warn('âš ï¸ Erro ao inicializar error handling:', error.message);
        }
    }

    /**
     * ðŸ›¡ï¸ InicializaÃ§Ã£o segura do monitoramento de performance
     */
    initSafePerformanceMonitoring() {
        try {
            const { performanceMonitor } = this.dependencies.singletons;

            if (performanceMonitor && performanceMonitor.initialize) {
                const initialized = performanceMonitor.initialize({
                    reportInterval: TIMING_CONFIG.PERFORMANCE.REPORT_INTERVAL,
                    alertThresholds: {
                        slowFunction: PERFORMANCE_THRESHOLDS.ALERTS.SLOW_FUNCTION,
                        highMemoryUsage: PERFORMANCE_THRESHOLDS.ALERTS.HIGH_MEMORY_USAGE,
                        domOperationsPerSecond:
                            PERFORMANCE_THRESHOLDS.ALERTS.DOM_OPERATIONS_PER_SECOND,
                    },
                });

                if (initialized) {
                    logger.debug('âœ… Performance monitoring ativo');
                } else {
                    logger.warn('âš ï¸ Performance monitoring nÃ£o inicializou');
                }
            }
        } catch (error) {
            logger.warn('âš ï¸ Erro ao inicializar performance monitoring:', error.message);
        }
    }

    /**
     * ðŸ›¡ï¸ InicializaÃ§Ã£o segura do cache manager
     */
    initSafeCacheManager() {
        try {
            const { cacheManager } = this.dependencies.singletons;

            if (cacheManager && cacheManager.configure) {
                cacheManager.configure({
                    maxSize: PERFORMANCE_THRESHOLDS.LIMITS.MAX_CACHE_SIZE,
                    defaultTTL: PERFORMANCE_THRESHOLDS.LIMITS.DEFAULT_CACHE_TTL,
                    enableCompression: false, // Desabilitado para reduzir overhead
                    enableStatistics: false, // Desabilitado para reduzir overhead
                });
                logger.debug('âœ… Cache manager ativo');
            }
        } catch (error) {
            logger.warn('âš ï¸ Erro ao inicializar cache manager:', error.message);
        }
    }

    /**
     * ðŸŽ¯ MÃ‰TODO PRINCIPAL - RESPONSABILIDADE ÃšNICA
     * Orquestra a inicializaÃ§Ã£o seguindo padrÃ£o Template Method
     */
    async init() {
        try {
            this._validateInitialization();
            this._startInitializationProcess();

            await this._initializeDependencyInjection();
            await this._initializeSupabaseConnection();
            await this._initializeMonitoringSystems();
            await this._initializeAdvancedStrategies();
            await this._initializeLegacyModules();
            await this._initializeStateManager(); // ðŸ†• CHECKPOINT 1.1
            await this._initializeDOMManager(); // ðŸ†• CHECKPOINT 2.1
            await this._initializeModularSystem(); // ðŸ†• CHECKPOINT 3.x
            await this._initializeRefactoredSystems();
            await this._initializeSidebar();

            // ðŸš€ Inicializa o novo Gerenciador de UI do Dashboard (Substitui fixes antigos)
            try {
                const { dashboardUIManager } = await import('./src/managers/DashboardUIManager.js');
                dashboardUIManager.init();
                logger.debug('âœ… DashboardUIManager inicializado com sucesso');
                this.initializationSteps.push('dashboard_ui_initialized');
            } catch (error) {
                logger.error('âŒ Erro ao inicializar DashboardUIManager:', error);
            }

            await this._performUISync();
            try { ui.__registerGlobalListenersOnce?.(); } catch (_) { }
            await this._performFinalValidations();

            this._completeInitialization();
        } catch (error) {
            this._handleInitializationError(error);
        }
    }

    /**
     * ðŸ­ InicializaÃ§Ã£o do Dependency Injector
     * @private
     */
    async _initializeDependencyInjection() {
        logger.debug('ðŸ­ Inicializando Dependency Injection...');

        try {
            // Registra mÃ³dulos legados para compatibilidade
            const legacyModules = {
                dom,
                dbManager,
                logic,
                events,
                ui,
                charts,
                state,
                config,
                CONSTANTS,
                // FunÃ§Ãµes especÃ­ficas exportadas
                calcularExpectativaMatematica,
                calcularDrawdown,
                calcularSequencias,
                calcularPayoffRatio,
                updateState,
            };

            // Inicializa o container de dependÃªncias
            this.dependencies = await dependencyInjector.initialize(legacyModules);

            logger.debug('âœ… Dependency Injection inicializado!');
            logger.debug('ðŸ“Š EstatÃ­sticas do DI:', dependencyInjector.getStats());

            this.initializationSteps.push('dependency_injection_initialized');
        } catch (error) {
            logger.error('âŒ Erro ao inicializar Dependency Injection:', error.message);
            throw new Error(`Falha crÃ­tica no Dependency Injection: ${error.message}`);
        }
    }

    /**
     * ðŸ›¡ï¸ ValidaÃ§Ã£o de inicializaÃ§Ã£o
     * @private
     */
    _validateInitialization() {
        if (this.initialized) {
            throw new Error('AplicaÃ§Ã£o jÃ¡ foi inicializada');
        }

        if (!this.validateNoRecursion()) {
            throw new Error('RecursÃ£o detectada - abortando inicializaÃ§Ã£o');
        }
    }

    /**
     * ðŸš€ Inicia processo de inicializaÃ§Ã£o
     * @private
     */
    _startInitializationProcess() {
        logger.debug('ðŸš€ MAIN: AplicaÃ§Ã£o modularizada iniciando... (Nova Arquitetura v9.3)');
        this.startTime = performance.now();
        this.initialized = true;
    }

    /**
     * ðŸ—„ï¸ InicializaÃ§Ã£o da conexÃ£o Supabase
     * @private
     */
    async _initializeSupabaseConnection() {
        logger.debug('ðŸ—„ï¸ Inicializando conexÃ£o Supabase...');

        let retryCount = 0;
        while (retryCount < this.INITIALIZATION_CONFIG.SUPABASE_RETRY_ATTEMPTS) {
            try {
                const supabaseConnected = await testSupabaseConnection();
                if (supabaseConnected) {
                    logger.debug(SYSTEM_MESSAGES.SUCCESS.SUPABASE_CONNECTED);
                    this.initializationSteps.push('supabase_connected');
                    return;
                }
                retryCount++;
            } catch (error) {
                retryCount++;
                logger.warn(
                    `âš ï¸ Tentativa ${retryCount} de conexÃ£o Supabase falhou:`,
                    error.message
                );
            }
        }

        logger.warn(SYSTEM_MESSAGES.WARNING.SUPABASE_FAILED);
        this.initializationSteps.push('supabase_failed');
    }

    /**
     * ðŸ“Š InicializaÃ§Ã£o dos sistemas de monitoramento
     * @private
     */
    async _initializeMonitoringSystems() {
        try {
            // ValidaÃ§Ã£o adicional de recursÃ£o
            if (!this.validateNoRecursion()) {
                throw new Error('RecursÃ£o detectada durante inicializaÃ§Ã£o de monitoramento');
            }

            // Inicializar sistemas com proteÃ§Ãµes
            this.initSafeErrorHandling();
            this.initSafePerformanceMonitoring();
            this.initSafeCacheManager();

            logger.debug('âœ… Sistemas de monitoramento seguros ativados');
            this.initializationSteps.push('monitoring_initialized');
        } catch (error) {
            logger.warn('âš ï¸ Erro ao inicializar monitoramento:', error.message);
            logger.debug('ðŸ”„ Continuando com sistema bÃ¡sico...');
            this.initializationSteps.push('monitoring_partial');
        }
    }

    /**
     * ðŸŽ¯ InicializaÃ§Ã£o das estratÃ©gias avanÃ§adas
     * @private
     */
    async _initializeAdvancedStrategies() {
        try {
            // Usa dependÃªncias injetadas
            const { registerAdvancedStrategies, demonstrateAdvancedStrategies } =
                this.dependencies.singletons;

            const strategiesRegistered = registerAdvancedStrategies();
            if (strategiesRegistered) {
                logger.debug('âœ… EstratÃ©gias avanÃ§adas registradas com sucesso!');
                demonstrateAdvancedStrategies();
                this.initializationSteps.push('strategies_registered');
            } else {
                logger.warn('âš ï¸ Falha ao registrar algumas estratÃ©gias avanÃ§adas');
                this.initializationSteps.push('strategies_partial');
            }
        } catch (error) {
            logger.error('âŒ Erro ao registrar estratÃ©gias:', error.message);
            this.initializationSteps.push('strategies_failed');
        }
    }

    /**
     * ðŸ—ï¸ InicializaÃ§Ã£o dos mÃ³dulos legados
     * @private
     */
    async _initializeLegacyModules() {
        try {
            // 1. Mapeia os elementos do DOM primeiro
            mapDOM();
            this.initializationSteps.push('dom_mapped');

            // ðŸš€ CORREÃ‡ÃƒO CRÃTICA: Inicializa componentes UI avanÃ§ados (Modal, Timeline, Tabela)
            // DEVE ser chamado APÃ“S mapDOM() mas ANTES de qualquer cÃ³digo que use os componentes
            initComponents();
            this.initializationSteps.push('ui_components_initialized');
            logger.debug('âœ… Componentes UI avanÃ§ados inicializados!');

            // 2. Inicia os mÃ³dulos que nÃ£o dependem do estado do utilizador
            // ðŸ›¡ï¸ RECOVERY: Retry logic para IndexedDB com delay exponencial
            let dbInitialized = false;
            let retryCount = 0;
            const maxRetries = 2;

            while (!dbInitialized && retryCount <= maxRetries) {
                try {
                    await dbManager.init();
                    dbInitialized = true;
                } catch (dbError) {
                    retryCount++;
                    if (retryCount <= maxRetries) {
                        const delay = retryCount * 500; // 500ms, 1000ms
                        logger.warn(`âš ï¸ Tentativa ${retryCount} de init falhou, retry em ${delay}ms...`, {
                            error: dbError.message
                        });
                        await new Promise(r => setTimeout(r, delay));
                    } else {
                        logger.error('âŒ Todas as tentativas de inicializar IndexedDB falharam');
                        // Continua sem IndexedDB - modo degradado
                        this.initializationSteps.push('database_failed');
                        logger.warn('âš ï¸ Continuando em modo degradado sem IndexedDB local');
                    }
                }
            }

            if (dbInitialized) {
                this.initializationSteps.push('database_initialized');
            }

            charts.init();
            this.initializationSteps.push('charts_initialized');

            // 3. Adiciona os event listeners para que possam reagir Ã s mudanÃ§as de estado
            events.init();
            this.initializationSteps.push('events_initialized');

            // 4. Carrega o estado guardado
            logic.loadStateFromStorage();
            this.initializationSteps.push('state_loaded');

            logger.debug('âœ… MÃ³dulos legados inicializados com sucesso!');

            // Renderiza o card principal a partir do template unificado
            try {
                // ExibiÃ§Ã£o do card principal desligada por padrÃ£o; fonte Ãºnica: sidebar
                if (window.__SHOW_MAIN_PARAMETERS_CARD__ === true) {
                    const inputPanel = dom.inputPanel;
                    if (inputPanel) {
                        const initialValues = {
                            capitalInicial: config.capitalInicial,
                            percentualEntrada: config.percentualEntrada,
                            stopWinPerc: config.stopWinPerc,
                            stopLossPerc: config.stopLossPerc,
                            estrategia: config.estrategiaAtiva,
                            payout: config.payout,
                        };
                        renderParametersCardIn(inputPanel, { idPrefix: '', values: initialValues });
                        try {
                            (window.parametersCardController ||= new ParametersCardController()).bindEventHandlers();
                        } catch (_) { }
                    }
                } else {
                    const inputPanel = dom.inputPanel;
                    if (inputPanel) inputPanel.innerHTML = '';
                }
            } catch (e) {
                logger.warn('âš ï¸ Falha ao renderizar card principal via template:', e.message);
            }
        } catch (error) {
            logger.error('âŒ Erro ao inicializar mÃ³dulos legados:', error.message);
            throw new Error(`Falha crÃ­tica na inicializaÃ§Ã£o de mÃ³dulos legados: ${error.message}`);
        }
    }

    /**
     * ðŸ†• CHECKPOINT 1.1: InicializaÃ§Ã£o do StateManager
     * @private
     */
    async _initializeStateManager() {
        try {
            logger.debug('ðŸ”„ CHECKPOINT 1.1: Inicializando StateManager...');

            // Importar StateManager
            const { stateManager, createBidirectionalSync } = await import('./state-manager.js');

            // Sincronizar estado inicial do window.state para o StateManager
            stateManager.setState(window.state, 'initial-sync-from-legacy');

            // Criar sincronizaÃ§Ã£o bidirecional (temporÃ¡ria)
            // Quando StateManager muda â†’ atualiza window.state
            createBidirectionalSync(stateManager, window.state);

            logger.debug('âœ… StateManager inicializado e sincronizado com estado legado');
            logger.debug('ðŸ“Š Estado inicial:', stateManager.getState());
            logger.debug('ðŸ“ˆ Stats:', stateManager.getStats());

            this.initializationSteps.push('state_manager_initialized');
        } catch (error) {
            logger.error('âŒ Erro ao inicializar StateManager:', error.message);
            logger.warn('âš ï¸ Continuando com estado legado apenas');
            this.initializationSteps.push('state_manager_failed');
        }
    }

    /**
     * ðŸ†• CHECKPOINT 2.1: InicializaÃ§Ã£o do DOMManager
     * @private
     */
    async _initializeDOMManager() {
        try {
            logger.debug('ðŸ”„ CHECKPOINT 2.1: Inicializando DOMManager...');

            // Importar DOMManager
            const { domManager } = await import('./dom-manager.js');

            logger.debug('âœ… DOMManager inicializado');
            logger.debug('ðŸ“Š Stats:', domManager.getStats());

            this.initializationSteps.push('dom_manager_initialized');
        } catch (error) {
            logger.error('âŒ Erro ao inicializar DOMManager:', error.message);
            logger.warn('âš ï¸ Continuando com DOM legado apenas');
            this.initializationSteps.push('dom_manager_failed');
        }
    }

    /**
     * ðŸ†• CHECKPOINT 3.x: InicializaÃ§Ã£o do Sistema Modular
     * @private
     */
    async _initializeModularSystem() {
        try {
            logger.debug('ðŸ—ï¸ CHECKPOINT 3.x: Inicializando Sistema Modular...');

            // Importar mÃ³dulos
            const { moduleManager } = await import('./src/modules/ModuleManager.js');
            const { default: SessionModule } = await import('./src/modules/SessionModule.js');
            const { default: OperationModule } = await import('./src/modules/OperationModule.js');
            const { default: CalculationModule } = await import('./src/modules/CalculationModule.js');

            // Criar instÃ¢ncias
            const sessionModule = new SessionModule();
            const operationModule = new OperationModule();
            const calculationModule = new CalculationModule();

            // Registrar dependÃªncias
            if (window.stateManager) {
                sessionModule.registerDependency('stateManager', window.stateManager);
                logger.debug('âœ… SessionModule conectado ao StateManager');
            }

            // Registrar mÃ³dulos no gerenciador
            moduleManager.register('session', sessionModule);
            moduleManager.register('operation', operationModule);
            moduleManager.register('calculation', calculationModule);

            // Inicializar todos os mÃ³dulos
            await moduleManager.initAll();

            // Expor globalmente para uso
            window.modules = {
                session: sessionModule,
                operation: operationModule,
                calculation: calculationModule,
                manager: moduleManager
            };

            logger.debug('âœ… Sistema Modular inicializado!');
            logger.debug('ðŸ“Š MÃ³dulos disponÃ­veis:', Object.keys(window.modules));
            logger.debug('ðŸ“ˆ Stats:', moduleManager.getStats());

            this.initializationSteps.push('modular_system_initialized');
        } catch (error) {
            logger.error('âŒ Erro ao inicializar Sistema Modular:', error.message);
            logger.warn('âš ï¸ Continuando sem sistema modular');
            this.initializationSteps.push('modular_system_failed');
        }
    }

    /**
     * ðŸ†• InicializaÃ§Ã£o dos sistemas refatorados
     * @private
     */
    async _initializeRefactoredSystems() {
        try {
            // Usa factory para criar Trading Manager com dependÃªncias injetadas
            this.tradingManager = this.dependencies.factories.createTradingManager(
                this.dependencies.legacy.state,
                this.dependencies.legacy.config,
                this.dependencies.legacy.dbManager,
                this.dependencies.legacy.ui,
                this.dependencies.legacy.charts
            );
            this.initializationSteps.push('trading_manager_created');

            // Usa singleton do Legacy Adapter
            const { legacyAdapter } = this.dependencies.singletons;

            // Inicializar o Legacy Integration Adapter
            await legacyAdapter.initialize({
                state: this.dependencies.legacy.state,
                config: this.dependencies.legacy.config,
                dbManager: this.dependencies.legacy.dbManager,
                ui: this.dependencies.legacy.ui,
                charts: this.dependencies.legacy.charts,
                tradingManager: this.tradingManager,
                logic: this.dependencies.legacy.logic,
                events: this.dependencies.legacy.events,
            });
            this.initializationSteps.push('legacy_adapter_initialized');

            // Criar proxies para manter compatibilidade
            legacyAdapter.createLegacyProxies(window.logic);
            this.initializationSteps.push('legacy_proxies_created');

            // Expor o novo manager globalmente para testes
            window.tradingManager = this.tradingManager;

            logger.debug('ðŸ”„ MigraÃ§Ã£o de compatibilidade configurada com sucesso!');
        } catch (error) {
            logger.error('âŒ Erro ao inicializar sistemas refatorados:', error.message);
            throw new Error(`Falha na inicializaÃ§Ã£o de sistemas refatorados: ${error.message}`);
        }
    }

    /**
     * ðŸ“‹ InicializaÃ§Ã£o da sidebar
     * @private
     */
    async _initializeSidebar() {
        try {
            // Importa e inicializa a sidebar dinamicamente
            const sidebarModule = await import('./sidebar.js');
            const sidebar = sidebarModule.sidebar;
            sidebar.initialize();

            // Expor globalmente para debug se necessÃ¡rio
            window.sidebar = sidebar;
            this.initializationSteps.push('sidebar_imported');

            // Aguarda um pouco antes de inicializar o gerenciador avanÃ§ado
            await new Promise((resolve) =>
                setTimeout(resolve, this.INITIALIZATION_CONFIG.SIDEBAR_INIT_DELAY)
            );

            // Inicializar o gerenciador avanÃ§ado
            const { sidebarManager } = await import('./src/ui/SidebarManager.js');
            sidebarManager.integrateWithSettings();
            this.initializationSteps.push('sidebar_manager_initialized');

            logger.debug('âœ… Sidebar inicializada com sucesso!');
        } catch (error) {
            logger.warn('âš ï¸ Erro ao inicializar sidebar:', error.message);
            this.initializationSteps.push('sidebar_failed');
            // NÃ£o Ã© crÃ­tico, continua a aplicaÃ§Ã£o
        }
    }

    /**
     * ðŸŽ¨ SincronizaÃ§Ã£o da UI
     * @private
     */
    async _performUISync() {
        try {
            // Timeout de seguranÃ§a para sincronizaÃ§Ã£o da UI
            const syncPromise = Promise.race([
                this._performActualUISync(),
                new Promise((_, reject) =>
                    setTimeout(
                        () => reject(new Error('Timeout na sincronizaÃ§Ã£o da UI')),
                        this.INITIALIZATION_CONFIG.UI_SYNC_TIMEOUT
                    )
                ),
            ]);

            await syncPromise;
            logger.debug('âœ… Interface sincronizada com sucesso!');
        } catch (error) {
            logger.error('âŒ Erro na sincronizaÃ§Ã£o da UI:', error.message);
            throw new Error(`Falha crÃ­tica na sincronizaÃ§Ã£o da UI: ${error.message}`);
        }
    }

    /**
     * ðŸŽ¨ Executa sincronizaÃ§Ã£o real da UI
     * @private
     */
    async _performActualUISync() {
        // Sincroniza a UI com o estado carregado
        ui.syncUIFromState();
        this.initializationSteps.push('ui_synced');

        // Renderiza todos os componentes com base no estado inicial
        ui.atualizarTudo();
        this.initializationSteps.push('ui_rendered');

        // Verifica se existe uma sessÃ£o por finalizar
        logic.checkForActiveSession();
        this.initializationSteps.push('session_checked');
    }

    /**
     * âœ… ValidaÃ§Ãµes finais
     * @private
     */
    async _performFinalValidations() {
        // Verificar se hÃ¡ bloqueio ativo
        const lockdownEnd = localStorage.getItem('gerenciadorProLockdownEnd');
        if (lockdownEnd && parseInt(lockdownEnd) > Date.now()) {
            const lockdownType = localStorage.getItem('gerenciadorProLockdownType') || 'perdas';
            ui.iniciarBloqueio(parseInt(lockdownEnd), lockdownType);
            this.initializationSteps.push('lockdown_activated');
            return;
        }

        // Mostrar container principal
        if (dom.container) {
            dom.container.classList.remove('hidden');
            this.initializationSteps.push('container_shown');
        }

        // Restaurar Ãºltima aba ativa
        const lastTab = logic.safeJSONParse(CONSTANTS.LAST_ACTIVE_TAB_KEY, 'plano');
        await events.onTabSwitch(lastTab);
        ui.switchTab(lastTab);
        this.initializationSteps.push('tab_restored');
    }

    /**
     * ðŸŽ‰ Finaliza processo de inicializaÃ§Ã£o
     * @private
     */
    _completeInitialization() {
        const endTime = performance.now();
        const initializationTime = (endTime - this.startTime).toFixed(2);

        logger.debug(
            `âœ¨ MAIN: AplicaÃ§Ã£o pronta! Nova arquitetura v9.3 ativa em ${initializationTime}ms`
        );
        logger.debug('ðŸ“ˆ MAIN: EstatÃ­sticas do sistema:', legacyAdapter.getStats());
        logger.debug('ðŸ”„ MAIN: Passos de inicializaÃ§Ã£o:', this.initializationSteps);

        this.initializationSteps.push('initialization_completed');
    }

    /**
     * âŒ Tratamento de erros de inicializaÃ§Ã£o
     * @private
     */
    _handleInitializationError(error) {
        logger.error('âŒ Erro durante inicializaÃ§Ã£o:', error);

        // Adiciona erro aos passos para diagnÃ³stico
        this.initializationSteps.push(`error_${error.name || 'unknown'}`);

        // Construir mensagem de erro detalhada
        let errorMessage = 'Erro ao inicializar o aplicativo.';
        if (error.message) {
            errorMessage += ` Detalhes: ${error.message}`;
        }

        // Log dos passos completados para diagnÃ³stico
        logger.debug('ðŸ” Passos completados antes do erro:', this.initializationSteps);

        // Tentativa de usar tratamento de erro avanÃ§ado se disponÃ­vel
        if (window.errorHandler && typeof window.errorHandler.handleError === 'function') {
            try {
                window.errorHandler.handleError(error, 'CRITICAL', {
                    context: 'App.init',
                    completedSteps: this.initializationSteps,
                    initializationTime: performance.now() - this.startTime,
                });
            } catch (handlerError) {
                logger.warn('âš ï¸ Erro no handler de erro:', handlerError.message);
            }
        }

        // Fallback para notificaÃ§Ã£o do usuÃ¡rio
        if (window.ui && window.ui.showNotification) {
            window.ui.showNotification('error', errorMessage);
        } else {
            // Ãšltimo recurso: exibir erro em tela completa
            document.body.innerHTML = `
                <div style="background: #ff1744; color: white; padding: 20px; text-align: center; font-family: Arial;">
                    <h2>âš ï¸ Erro de InicializaÃ§Ã£o</h2>
                    <p>A aplicaÃ§Ã£o nÃ£o pÃ´de ser carregada corretamente.</p>
                    <details style="margin-top: 10px;">
                        <summary>Detalhes tÃ©cnicos</summary>
                        <pre style="text-align: left; background: rgba(0,0,0,0.3); padding: 10px; margin-top: 10px; border-radius: 4px;">${error.message}</pre>
                        <p style="text-align: left; margin-top: 10px;"><strong>Passos completados:</strong> ${this.initializationSteps.join(', ')}</p>
                    </details>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: white; color: #ff1744; border: none; border-radius: 4px; cursor: pointer;">ðŸ”„ Recarregar PÃ¡gina</button>
                </div>
            `;
        }

        // Re-throw para permitir handling adicional se necessÃ¡rio
        throw error;
    }
}

/**
 * ðŸš€ PONTO DE ENTRADA DA APLICAÃ‡ÃƒO
 * InicializaÃ§Ã£o limpa e controlada
 */
document.addEventListener('DOMContentLoaded', async () => {
    logger.debug('ðŸ“± DOM carregado, inicializando aplicaÃ§Ã£o...');

    const app = new App();

    try {
        await app.init();
        logger.debug('âœ… AplicaÃ§Ã£o inicializada com sucesso!');

        // ðŸ” Purga automÃ¡tica da Lixeira: agora e diariamente
        try {
            if (window.dbManager && typeof dbManager.purgeExpiredTrash === 'function') {
                dbManager.purgeExpiredTrash().catch(() => { });
                setInterval(() => dbManager.purgeExpiredTrash().catch(() => { }), 24 * 60 * 60 * 1000);
            }
        } catch (_) { }
    } catch (error) {
        logger.error('âŒ Falha crÃ­tica na inicializaÃ§Ã£o:', error);

        // O tratamento de erro detalhado jÃ¡ foi feito no _handleInitializationError
        // Aqui apenas garantimos que o erro seja logado
        logger.debug('ðŸ” InicializaÃ§Ã£o falhou. Veja logs detalhados acima.');
    }
});

// Exporta o cliente Supabase para uso em outros mÃ³dulos
export { supabase };

// FunÃ§Ãµes de limpeza de dados corrompidos (disponÃ­veis no console)
window.clearCorruptedData = async () => {
    logger.debug('ðŸ§¹ Iniciando limpeza de dados corrompidos...');
    try {
        const removed = await dbManager.clearCorruptedData();
        logger.debug(`âœ… ${removed} sessÃµes corrompidas removidas.`);
        if (removed > 0) {
            // Recarregar a aba diÃ¡rio
            if (typeof ui !== 'undefined' && ui.renderDiario) {
                ui.renderDiario();
            }
        }
        return removed;
    } catch (error) {
        logger.error('âŒ Erro:', error);
        return 0;
    }
};

window.repairCorruptedData = async () => {
    logger.debug('ðŸ”§ Iniciando reparo de dados corrompidos...');
    try {
        const repaired = await dbManager.repairCorruptedData();
        logger.debug(`âœ… ${repaired} sessÃµes reparadas.`);
        if (repaired > 0) {
            // Recarregar a aba diÃ¡rio
            if (typeof ui !== 'undefined' && ui.renderDiario) {
                ui.renderDiario();
            }
        }
        return repaired;
    } catch (error) {
        logger.error('âŒ Erro:', error);
        return 0;
    }
};

// ðŸ”§ FunÃ§Ã£o para reparar resultados financeiros zerados
window.repairResultadosZerados = async () => {
    logger.debug('ðŸ”§ Iniciando reparo de resultados financeiros zerados...');
    try {
        const result = await dbManager.repairInvalidResultados();
        logger.debug(`âœ… Reparo concluÃ­do:`, result);
        if (result.repaired > 0) {
            // Recarregar a aba diÃ¡rio
            if (typeof ui !== 'undefined' && ui.renderDiario) {
                ui.renderDiario();
            }
        }
        return result;
    } catch (error) {
        logger.error('âŒ Erro:', error);
        return { repaired: 0, errors: 1, error: error.message };
    }
};

// Nota importante: Agora vocÃª pode importar o cliente Supabase em outros mÃ³dulos usando:
// import { supabase } from './main.js';

// =================================================================
// SISTEMA DE TESTE PARA SINCRONIZAÃ‡ÃƒO EM TEMPO REAL
// =================================================================

// FunÃ§Ã£o para testar a sincronizaÃ§Ã£o entre cards
window.testRealTimeSync = function () {
    logger.debug('\nðŸ§ª TESTANDO SINCRONIZAÃ‡ÃƒO EM TEMPO REAL...\n');

    // Teste 1: Capital Inicial
    logger.debug('ðŸ“ Teste 1: MudanÃ§a no capital inicial');
    const capitalInput = dom.capitalInicial;
    if (capitalInput) {
        capitalInput.value = '15000';
        capitalInput.dispatchEvent(new Event('change', { bubbles: true }));

        setTimeout(() => {
            const sidebarCapital = dom.sidebarCapitalInicial;
            if (sidebarCapital) {
                logger.debug(`âœ… Capital sincronizado: ${sidebarCapital.value}`);
            } else {
                logger.debug('âš ï¸ Sidebar nÃ£o estÃ¡ aberto para teste');
            }
        }, 200);
    }

    // Teste 2: Entrada Inicial
    setTimeout(() => {
        logger.debug('ðŸ“ Teste 2: MudanÃ§a na entrada inicial');
        const entradaInput = dom.percentualEntrada;
        if (entradaInput) {
            entradaInput.value = '3.5';
            entradaInput.dispatchEvent(new Event('change', { bubbles: true }));
            logger.debug('âœ… Entrada alterada para 3.5%');
        }
    }, 300);

    // Teste 3: Payout
    setTimeout(() => {
        logger.debug('ðŸ“ Teste 3: MudanÃ§a de payout');
        const payoutBtn = Array.from(document.querySelectorAll('.payout-buttons button')).find(
            (btn) => btn.textContent.trim() === '90'
        );
        if (payoutBtn) {
            payoutBtn.click();
            logger.debug('âœ… Payout 90% selecionado');
        }
    }, 600);

    // Teste 4: EstratÃ©gia
    setTimeout(() => {
        logger.debug('ðŸ“ Teste 4: MudanÃ§a de estratÃ©gia');
        const strategySelect = dom.estrategiaSelect;
        if (strategySelect) {
            strategySelect.value = 'fixa';
            strategySelect.dispatchEvent(new Event('change', { bubbles: true }));
            logger.debug('âœ… EstratÃ©gia alterada para MÃ£o Fixa');
        }
    }, 900);

    // Teste 5: Stop Win
    setTimeout(() => {
        logger.debug('ðŸ“ Teste 5: MudanÃ§a no Stop Win');
        const stopWinInput = dom.stopWinPerc;
        if (stopWinInput) {
            stopWinInput.value = '12';
            stopWinInput.dispatchEvent(new Event('change', { bubbles: true }));
            logger.debug('âœ… Stop Win alterado para 12%');
        }
    }, 1200);

    // Teste 6: Stop Loss
    setTimeout(() => {
        logger.debug('ðŸ“ Teste 6: MudanÃ§a no Stop Loss');
        const stopLossInput = dom.stopLossPerc;
        if (stopLossInput) {
            stopLossInput.value = '18';
            stopLossInput.dispatchEvent(new Event('change', { bubbles: true }));
            logger.debug('âœ… Stop Loss alterado para 18%');
        }

        // Resumo final
        setTimeout(() => {
            logger.debug('\nðŸŽ¯ TESTE CONCLUÃDO!');
            logger.debug('ðŸ“‹ Para testar sincronizaÃ§Ã£o do sidebar:');
            logger.debug('1. Abra o menu lateral (botÃ£o â˜°)');
            logger.debug('2. Clique em "ParÃ¢metros e Controles"');
            logger.debug('3. Altere valores e veja a sincronizaÃ§Ã£o automÃ¡tica');
            logger.debug('4. Note que NÃƒO hÃ¡ botÃ£o "Aplicar" - tudo Ã© automÃ¡tico!');
            logger.debug('\nðŸ’¡ Execute: testRealTimeSync() no console para testar novamente');
        }, 500);
    }, 1500);
};

// =================================================================
// SISTEMA DE TESTE PARA SINCRONIZAÃ‡ÃƒO DE PAYOUT + VISUAL FOCUS
// =================================================================
window.testPayoutAndFocus = function () {
    logger.debug('\nðŸ§ª TESTANDO PAYOUT SYNC + VISUAL FOCUS...\n');

    let testIndex = 0;
    const tests = [
        // Teste 1: Payout Sync Main â†’ Sidebar
        () => {
            logger.debug('ðŸ“ Teste 1: Payout 90% no card principal');
            const btn = Array.from(document.querySelectorAll('.payout-buttons button')).find(
                (b) => b.textContent.trim() === '90'
            );
            if (btn) {
                btn.click();
                logger.debug('âœ… Clique executado no payout 90%');
            } else {
                logger.debug('âŒ BotÃ£o payout 90% nÃ£o encontrado');
            }
        },

        // Teste 2: Verificar sincronizaÃ§Ã£o no sidebar
        () => {
            logger.debug('ðŸ“ Teste 2: Verificando sincronizaÃ§Ã£o no sidebar');
            const sidebarBtn = dom.sidebarPayout - 90;
            if (sidebarBtn && sidebarBtn.classList.contains('active-payout')) {
                logger.debug('âœ… Sidebar sincronizado corretamente');
            } else if (!sidebarBtn) {
                logger.debug('âš ï¸ Sidebar nÃ£o estÃ¡ aberto - abra o menu lateral primeiro');
            } else {
                logger.debug('âŒ Sidebar NÃƒO sincronizado');
            }
        },

        // Teste 3: Focus Effect (Verde Elegante)
        () => {
            logger.debug('ðŸ“ Teste 3: Efeito de focus verde elegante no capital inicial');
            const capitalField = dom.capitalInicial;
            if (capitalField) {
                capitalField.focus();
                setTimeout(() => {
                    const computedStyle = window.getComputedStyle(capitalField);
                    const borderColor = computedStyle.borderColor;
                    const boxShadow = computedStyle.boxShadow;

                    // Verifica se tem verde elegante (76, 175, 80)
                    const hasCorrectGreen =
                        borderColor.includes('76, 175, 80') || boxShadow.includes('76, 175, 80');

                    // Verifica se NÃƒO tem cores indesejadas (amarelo/dourado)
                    const hasUnwantedColors =
                        borderColor.includes('230, 118') ||
                        boxShadow.includes('230, 118') ||
                        borderColor.includes('255, 255, 0') ||
                        boxShadow.includes('255, 193');

                    if (hasCorrectGreen && !hasUnwantedColors) {
                        logger.debug('âœ… Efeito verde ELEGANTE aplicado corretamente');
                    } else if (hasUnwantedColors) {
                        logger.debug('âŒ AINDA tem cores indesejadas (amarelo/dourado)');
                        logger.debug('ðŸ” Border:', borderColor);
                        logger.debug('ðŸ” Shadow:', boxShadow);
                    } else {
                        logger.debug('âŒ Efeito verde NÃƒO aplicado');
                        logger.debug('ðŸ” Border:', borderColor);
                        logger.debug('ðŸ” Shadow:', boxShadow);
                    }
                }, 100);
            } else {
                logger.debug('âŒ Campo capital inicial nÃ£o encontrado');
            }
        },

        // Teste 4: Typing Effect
        () => {
            logger.debug('ðŸ“ Teste 4: Efeito de digitaÃ§Ã£o');
            const capitalField = dom.capitalInicial;
            if (capitalField) {
                capitalField.value = '25000';
                capitalField.dispatchEvent(new Event('input', { bubbles: true }));

                setTimeout(() => {
                    if (capitalField.classList.contains('typing')) {
                        logger.debug('âœ… Efeito de digitaÃ§Ã£o ativo');
                    } else {
                        logger.debug('ðŸ’¡ Efeito de digitaÃ§Ã£o pode ter expirado (normal)');
                    }
                }, 50);
            }
        },

        // Teste 5: Payout Sidebar â†’ Main (se sidebar estiver aberto)
        () => {
            logger.debug('ðŸ“ Teste 5: Payout 92% no sidebar');
            const sidebarBtn = dom.sidebarPayout - 92;
            if (sidebarBtn) {
                sidebarBtn.click();
                logger.debug('âœ… Clique executado no sidebar');

                setTimeout(() => {
                    const mainBtn = Array.from(
                        document.querySelectorAll('.payout-buttons button')
                    ).find((b) => b.textContent.trim() === '92');
                    if (mainBtn && mainBtn.classList.contains('active-payout')) {
                        logger.debug('âœ… Card principal sincronizado');
                    } else {
                        logger.debug('âŒ Card principal NÃƒO sincronizado');
                    }
                }, 100);
            } else {
                logger.debug('âš ï¸ BotÃ£o do sidebar nÃ£o encontrado - abra o menu lateral');
            }
        },

        // Teste 6: Focus no sidebar (se estiver aberto)
        () => {
            logger.debug('ðŸ“ Teste 6: Focus no sidebar');
            const sidebarField = dom.sidebarCapitalInicial;
            if (sidebarField) {
                sidebarField.focus();
                setTimeout(() => {
                    const computedStyle = window.getComputedStyle(sidebarField);
                    const hasGreenBorder =
                        computedStyle.borderColor.includes('230, 118') ||
                        computedStyle.boxShadow.includes('230, 118');
                    if (hasGreenBorder) {
                        logger.debug('âœ… Efeito de focus no sidebar funcionando');
                    } else {
                        logger.debug('âŒ Efeito de focus no sidebar NÃƒO funcionando');
                    }
                }, 100);
            } else {
                logger.debug(
                    'âš ï¸ Campo do sidebar nÃ£o encontrado - abra ParÃ¢metros e Controles no menu lateral'
                );
            }
        },
    ];

    // Executar testes sequencialmente
    function runNextTest() {
        if (testIndex < tests.length) {
            tests[testIndex]();
            testIndex++;
            setTimeout(runNextTest, 800);
        } else {
            logger.debug('\nðŸŽ¯ TODOS OS TESTES CONCLUÃDOS!');
            logger.debug('ðŸ’¡ Para testar completamente:');
            logger.debug('1. Abra o menu lateral (botÃ£o â˜°)');
            logger.debug('2. Clique em "ParÃ¢metros e Controles"');
            logger.debug('3. Execute novamente: testPayoutAndFocus()');
            logger.debug('4. Teste manualmente clicando nos botÃµes e campos');
        }
    }

    runNextTest();
};

// =================================================================
// TESTE ESPECÃFICO PARA VALIDAÃ‡ÃƒO DO DESAFIO DE BORDAS VERDES
// =================================================================
window.testGreenBorderChallenge = function () {
    logger.debug('\nðŸŽ¯ TESTE DO DESAFIO: BORDAS VERDES ELEGANTES\n');

    // Teste 1: VerificaÃ§Ã£o Visual Stop Win
    logger.debug('ðŸ“ Testando campo Stop Win (%) - o que estava com problema...');
    const stopWinField = dom.stopWinPerc;
    if (stopWinField) {
        stopWinField.focus();

        setTimeout(() => {
            const style = window.getComputedStyle(stopWinField);
            const border = style.borderColor;
            const shadow = style.boxShadow;

            logger.debug('ðŸ” Border atual:', border);
            logger.debug('ðŸ” Shadow atual:', shadow);

            // Verifica verde elegante (76, 175, 80)
            const hasCorrectGreen =
                border.includes('76, 175, 80') || shadow.includes('76, 175, 80');

            // Verifica se NÃƒO tem amarelo/dourado (230, 118 ou outras cores indesejadas)
            const hasYellow = border.includes('230, 118') || shadow.includes('230, 118');
            const hasGold = border.includes('255, 193') || shadow.includes('255, 193');
            const hasUnwantedColors = hasYellow || hasGold;

            if (hasCorrectGreen && !hasUnwantedColors) {
                logger.debug('âœ… SUCESSO! Apenas verde elegante, sem amarelo/dourado');
            } else if (hasUnwantedColors) {
                logger.debug('âŒ FALHA! Ainda tem cores indesejadas');
                if (hasYellow) logger.debug('ðŸŸ¡ Detectado: Verde saturado (230, 118)');
                if (hasGold) logger.debug('ðŸŸ¨ Detectado: Dourado/Amarelo');
            } else {
                logger.debug('âŒ FALHA! Verde elegante nÃ£o aplicado');
            }

            stopWinField.blur();
        }, 200);
    }

    // Teste 2: Todos os campos principais
    setTimeout(() => {
        logger.debug('\nðŸ“ Testando TODOS os campos principais...');
        const fields = [
            'capital-inicial',
            'percentual-entrada',
            'stop-win-perc',
            'stop-loss-perc',
            'estrategia-select',
        ];

        let testsPassed = 0;
        fields.forEach((fieldId, index) => {
            setTimeout(() => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.focus();

                    setTimeout(() => {
                        const style = window.getComputedStyle(field);
                        const hasGreen =
                            style.borderColor.includes('76, 175, 80') ||
                            style.boxShadow.includes('76, 175, 80');
                        const hasUnwanted =
                            style.borderColor.includes('230, 118') ||
                            style.boxShadow.includes('230, 118');

                        if (hasGreen && !hasUnwanted) {
                            logger.debug(`âœ… ${fieldId}: Verde elegante OK`);
                            testsPassed++;
                        } else {
                            logger.debug(`âŒ ${fieldId}: Problema detectado`);
                        }

                        field.blur();

                        if (index === fields.length - 1) {
                            logger.debug(
                                `\nðŸŽ¯ RESULTADO: ${testsPassed}/${fields.length} campos corretos`
                            );
                            if (testsPassed === fields.length) {
                                logger.debug('ðŸŽ‰ DESAFIO CONCLUÃDO COM SUCESSO!');
                                logger.debug('âœ¨ Todas as bordas sÃ£o verdes elegantes');
                                logger.debug('ðŸš« Nenhuma cor indesejada detectada');
                            } else {
                                logger.debug('âš ï¸ Alguns campos ainda precisam de ajuste');
                            }
                        }
                    }, 100);
                }
            }, index * 300);
        });
    }, 1000);
};

// Executa teste automÃ¡tico quando a aplicaÃ§Ã£o inicializar
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (window.realTimeSync) {
            logger.debug('âœ… Sistema de sincronizaÃ§Ã£o em tempo real ativo');
            logger.debug('ðŸš€ Executando teste automÃ¡tico em 2 segundos...');
            setTimeout(() => {
                window.testRealTimeSync();
            }, 2000);
        }

        // Novo teste para payout e focus
        if (window.payoutSync && window.fieldFocusManager) {
            logger.debug('ðŸš€ Executando testes avanÃ§ados de payout e focus em 5 segundos...');
            setTimeout(() => {
                window.testPayoutAndFocus();
            }, 5000);
        }
    }, 1000);
});

/**
 * ðŸ§ª FUNÃ‡ÃƒO DE TESTE - Initialization
 * Testa se todos os sistemas foram inicializados corretamente
 */
function testInitialization() {
    logger.debug('ðŸ§ª Testando inicializaÃ§Ã£o do sistema...');

    const startTime = performance.now();
    const results = {
        supabase: false,
        globalObjects: false,
        strategiesRegistered: false,
        tradingManager: false,
        domMapped: false,
        overall: false,
    };

    try {
        // 1. Teste de conexÃ£o Supabase
        logger.debug('ðŸ—„ï¸ Testando conexÃ£o Supabase...');
        try {
            if (typeof supabase !== 'undefined' && supabase) {
                results.supabase = true;
                logger.debug('âœ… Supabase: Conectado');
            } else {
                logger.warn('âš ï¸ Supabase: NÃ£o conectado');
            }
        } catch (error) {
            logger.warn('âš ï¸ Supabase:', error.message);
        }

        // 2. Teste de objetos globais
        logger.debug('ðŸŒ Testando objetos globais...');
        try {
            const globalObjects = [
                'config',
                'state',
                'logic',
                'ui',
                'dom',
                'charts',
                'sidebar',
                'cssResolver',
            ];

            let foundObjects = 0;
            globalObjects.forEach((obj) => {
                if (typeof window[obj] !== 'undefined') {
                    foundObjects++;
                    logger.debug(`âœ… ${obj}: disponÃ­vel`);
                } else {
                    logger.debug(`âŒ ${obj}: nÃ£o encontrado`);
                }
            });

            if (foundObjects >= 6) {
                results.globalObjects = true;
                logger.debug(`âœ… Objetos globais: ${foundObjects}/${globalObjects.length}`);
            }
        } catch (error) {
            logger.warn('âš ï¸ Objetos globais:', error.message);
        }

        // 3. Teste de estratÃ©gias registradas
        logger.debug('ðŸŽ¯ Testando estratÃ©gias...');
        try {
            if (typeof window.registerAdvancedStrategies === 'function') {
                results.strategiesRegistered = true;
                logger.debug('âœ… EstratÃ©gias: Registradas');
            }
        } catch (error) {
            logger.warn('âš ï¸ EstratÃ©gias:', error.message);
        }

        // 4. Teste de Trading Manager
        logger.debug('ðŸ’¼ Testando Trading Manager...');
        try {
            if (typeof window.tradingManager !== 'undefined' && window.tradingManager) {
                results.tradingManager = true;
                logger.debug('âœ… Trading Manager: Ativo');
            } else {
                logger.warn('âš ï¸ Trading Manager: NÃ£o encontrado');
            }
        } catch (error) {
            logger.warn('âš ï¸ Trading Manager:', error.message);
        }

        // 5. Teste de DOM mapeado
        logger.debug('ðŸ—ºï¸ Testando DOM mapeado...');
        try {
            if (typeof dom !== 'undefined' && Object.keys(dom).length > 10) {
                results.domMapped = true;
                logger.debug(`âœ… DOM: ${Object.keys(dom).length} elementos mapeados`);
            } else {
                logger.warn('âš ï¸ DOM: Poucos elementos mapeados');
            }
        } catch (error) {
            logger.warn('âš ï¸ DOM:', error.message);
        }

        // Resultado geral
        const successCount = Object.values(results).filter(Boolean).length;
        results.overall = successCount >= 3; // Pelo menos 3 de 5 testes

        const endTime = performance.now();
        logger.debug(`â±ï¸ Testes Initialization executados em ${(endTime - startTime).toFixed(2)}ms`);

        if (results.overall) {
            logger.debug('âœ… INITIALIZATION: Sistema inicializado corretamente!');
        } else {
            logger.warn('âš ï¸ INITIALIZATION: Alguns componentes nÃ£o inicializados');
        }

        return results;
    } catch (error) {
        logger.error('âŒ Erro crÃ­tico nos testes Initialization:', error);
        return { ...results, overall: false };
    }
}

// ExposiÃ§Ã£o global
if (typeof window !== 'undefined') {
    window.testInitialization = testInitialization;
    logger.debug('ðŸ§ª testInitialization() disponÃ­vel globalmente');
}
