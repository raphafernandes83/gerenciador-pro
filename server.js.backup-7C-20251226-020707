import { createServer } from 'http';
import { access, constants } from 'fs/promises';
import { createReadStream } from 'fs';
import { join, extname, resolve } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// ESM __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const server = createServer(async (req, res) => {
    try {
        // Remove query string e parse da URL
        let filePath = req.url.split('?')[0];

        // Root vai para index.html
        if (filePath === '/') {
            filePath = '/index.html';
        }

        // üõ°Ô∏è PROTE√á√ÉO CONTRA PATH TRAVERSAL
        // Normalizar e resolver o caminho completo
        const fullPath = resolve(join(__dirname, filePath));

        // Verificar se o caminho resolvido est√° dentro do diret√≥rio permitido
        if (!fullPath.startsWith(__dirname)) {
            console.warn(`‚ö†Ô∏è Path traversal attempt blocked: ${req.url}`);
            res.writeHead(403, { 'Content-Type': 'text/html; charset=utf-8' });
            res.end('<h1>403 - Acesso negado</h1>');
            return;
        }

        // Bloquear acesso a arquivos ocultos (come√ßam com .)
        const fileName = fullPath.split(/[\\/]/).pop();
        if (fileName.startsWith('.')) {
            console.warn(`‚ö†Ô∏è Hidden file access blocked: ${fileName}`);
            res.writeHead(403, { 'Content-Type': 'text/html; charset=utf-8' });
            res.end('<h1>403 - Acesso negado</h1>');
            return;
        }

        // Extens√£o do arquivo
        const ext = extname(filePath);

        // MIME types com charset UTF-8 para textos
        const mimeTypes = {
            '.html': 'text/html; charset=utf-8',
            '.js': 'application/javascript; charset=utf-8',
            '.css': 'text/css; charset=utf-8',
            '.json': 'application/json; charset=utf-8',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.ico': 'image/x-icon',
        };

        const contentType = mimeTypes[ext] || 'text/plain; charset=utf-8';

        // Verifica se arquivo existe (async/await)
        try {
            await access(fullPath, constants.F_OK);
        } catch {
            res.writeHead(404, { 'Content-Type': 'text/html' });
            res.end('<h1>404 - Arquivo n√£o encontrado</h1>');
            return;
        }

        // L√™ o arquivo usando stream (evita carregar tudo na mem√≥ria)
        const fileStream = createReadStream(fullPath);

        res.writeHead(200, {
            'Content-Type': contentType,
            'Cache-Control': 'no-cache',
            // üõ°Ô∏è Security Headers
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'DENY',
            'X-XSS-Protection': '1; mode=block',
            'Referrer-Policy': 'strict-origin-when-cross-origin',
            'Content-Security-Policy': "default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' data: https://fonts.gstatic.com; connect-src 'self' https: wss: https://*.supabase.co; object-src 'none'; base-uri 'self'; frame-ancestors 'none';",
            // üß™ CSP Report-Only: Testa style-src sem unsafe-inline
            'Content-Security-Policy-Report-Only': "default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com; style-src 'self' https://fonts.googleapis.com; img-src 'self' data: https:; font-src 'self' data: https://fonts.gstatic.com; connect-src 'self' https: wss: https://*.supabase.co; object-src 'none'; base-uri 'self'; frame-ancestors 'none';",
        });

        // Pipe do stream para a resposta
        fileStream.pipe(res);

        // Tratamento de erro no stream
        fileStream.on('error', (streamErr) => {
            console.error('Stream error:', streamErr);
            if (!res.headersSent) {
                res.writeHead(500, { 'Content-Type': 'text/html; charset=utf-8' });
                res.end('<h1>500 - Erro ao ler arquivo</h1>');
            }
        });

    } catch (err) {
        const timestamp = new Date().toISOString();
        console.error(`[${timestamp}] Server error:`, {
            message: err.message,
            code: err.code,
            path: req.url,
        });

        // Diferenciar tipos de erro
        if (err.code === 'EACCES' || err.code === 'EPERM') {
            res.writeHead(403, { 'Content-Type': 'text/html; charset=utf-8' });
            res.end('<h1>403 - Acesso negado</h1>');
        } else if (err.code === 'ENOENT') {
            res.writeHead(404, { 'Content-Type': 'text/html; charset=utf-8' });
            res.end('<h1>404 - Arquivo n√£o encontrado</h1>');
        } else {
            res.writeHead(500, { 'Content-Type': 'text/html; charset=utf-8' });
            res.end('<h1>500 - Erro interno do servidor</h1>');
        }
    }
});

const PORT = 3000;
server.listen(PORT, () => {
    console.log(`üöÄ Servidor modernizado rodando em http://localhost:${PORT}`);
});
